. Occasionally, we'll want to run one command right after another. To do that, we can use the ; (semicolon):

With &&, the command to the right will not run if the command to the left fails. ; and && can both be used multiple times on the same line --> with ;, the second command will run even if the first one fails:

Putting & after a command prevents this from happening, and lets you execute a new command while an older one is still going:

head outputs the first few lines of a file. The -n flag specifies the number of lines to show (the default is 10):

tail outputs the last few lines of a file. You can get the last n lines (like above), or you can get the end of the file beginning from the N-th line with tail -n +N:

cat concatenates a list of files and sends them to the standard output stream (usually the terminal). cat can be used with just a single file, or multiple files, and is often used to quickly view them

less is another tool for quickly viewing a file -- it opens up a vim-like read-only window. (Yes, there is a command called more, but less -- unintuitively -- offers a superset of the functionality of more and is recommended over it.) 

ln creates a hard link to a file:

# first argument to ln is TARGET, second is NEW LINK
11:31 | andrew@pc01 ex | ln b f && ls
b  c  d  e  e2  f
ln -s creates a soft link to a file:

11:31 | andrew@pc01 ex | ln -s b g && ls
b  c  d  e  e2  f  g

Hard links reference the same actual bytes in memory which contain a file, while soft links refer to the original file name, which itself points to those bytes. You can read more about soft vs. hard links here.

...hit ^r (Ctrl+r) to search the command history...

But if we pass the -p flag to mkdir, it will make all directories in the path if they don't already exist:

tree can help you better visualise a directory's structure by printing a nicely-formatted directory tree. By default, it prints the entire tree structure (beginning with the specified directory), but you can restrict it to a certain number of levels with the -L flag:

df is used to show how much space is taken up by files for the disks or your system (hard drives, etc.).
	In the above command, -h doesn't mean "help", but "human-readable". Some commands use this convention to display file / disk sizes with K for kilobytes, G for gigabytes, and so on, instead of writing out a gigantic integer number of bytes.
	
du shows file space usage for a particular directory and its subdirectories. If you want to know how much space is free on a given hard drive, use df; if you want to know how much space a directory is taking up, use du:

Environment variables (sometimes shortened to "env vars") are persistent variables that can be created and used within your bash shell. They are defined with an equals sign (=) and used with a dollar sign ($). You can see all currently-defined env vars with printenv:

A shell script can be executed with the source command or the sh command:

Long lines of code can be split by ending a command with \:

$PS1 (Prompt String 1) is the environment variable that defines your main shell prompt (learn about the other prompts here):

Note that bash scripts can source other scripts. For instance, in your ~/.bashrc, you could include the line:

I try to keep separate bash files for aesthetic configurations and OS- or machine-specific code, and then I have one big bash file containing shortcuts, etc. that I use on every machine and every OS.

whereis searches for "possibly useful" files related to a particular command. It will attempt to return the location of the binary (executable machine code), source (code source files), and man page for that command:

which will only return the location of the binary (the command itself):

whatis prints out the one-line description of a command from its man page:

which is useful for finding the "original version" of a command which may be hidden by an alias:

locate finds a file anywhere on the system by referring to a semi-regularly-updated cached list of files:

Because it's just searching a list, locate is usually faster than the alternative, find. find iterates through the file system to find the file you're looking for. Because it's actually looking at the files which currently exist on the system, though, it will always return an up-to-date list of files, which is not necessarily true with locate.

When you need a fast (but possibly outdated) list of files, or you’re not sure what directory a particular file is in, use locate. When you need an accurate file list, maybe based on something other than the files’ names, and you need to do something with those files, use find.

The pipe operator, |, redirects the output of the first command to the input of the second command:

> redirects output from stdout to a particular location

printf is an improved echo, allowing formatting and escape sequences:

< gets input from a particular location, rather than stdin:

0, 1, and 2 are the standard input, output, and error streams, respectively. Input and output streams can be redirected with the |, >, and < operators mentioned previously, but stdin, stdout, and stderr can also be manipulated directly using their numeric identifiers:

Write to stdout or stderr with >&1 or >&2:

Files may be able to be read (r), written to (w), and/or executed (x) by different users or groups of users, or not at all. File permissions can be seen with the ls -l command and are represented by 10 characters:

The first character of each line represents the type of file, (d = directory, l = link, - = regular file, and so on); then there are three groups of three characters which represent the permissions held by the user (u) who owns the file, the permissions held by the group (g) which owns the file, and the permissions held any other (o) users. (The number which follows this string of characters is the number of links in the file system to that file (4 or 1 above).)

r means that person / those people have read permission, w is write permission, x is execute permission. If a directory is “executable”, that means it can be opened and its contents can be listed. These three permissions are often represented with a single three-digit number, where, if x is enabled, the number is incremented by 1, if w is enabled, the number is incremented by 2, and if r is enabled, the number is incremented by 4. Note that these are equivalent to binary digits (r-x -> 101 -> 5, for example). So the above three files have permissions of 755, 755, and 644, respectively.

The next two strings in each list are the name of the owner (andrew, in this case) and the group of the owner (also andrew, in this case). Then comes the size of the file, its most recent modification time, and its name. The –h flag makes the output human readable (i.e. printing 4.0K instead of 4096 bytes).

cmp reports which bytes differ between two files:

cut is usually used to cut a line into sections on some delimiter (good for CSV processing). -d specifies the delimiter and -f specifies the field index to print (starting with 1 for the first field):

sed is commonly used to replace a string with another string in a file:

As a rule of thumb, grep is good for finding strings and patterns in files, sed is good for one-to-one replacement of strings in files, and awk is good for extracting strings and patterns from files and analysing them


https://dev.to/awwsmm/101-bash-commands-and-tips-for-beginners-to-experts-30je?utm_source=Newsletter+Subscribers&utm_campaign=bd8f7b0ddf-EMAIL_CAMPAIGN_2019_01_14_07_51&utm_medium=email&utm_term=0_d8f11d5d1e-bd8f7b0ddf-154737769#intermediate
